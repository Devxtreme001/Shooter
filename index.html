<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Gesture Shooter</title>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #video-container { position: fixed; width: 100%; height: 100%; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); font-size: 24px;
        }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 100;
        }

        .vfx-text {
            position: absolute; font-weight: bold; pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100px); opacity: 0; }
        }

        .loader {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db;
            border-radius: 50%; width: 50px; height: 50px; animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="loader"></div>
        <div id="status">Loading MediaPipe Models (v0.4.1646424915)...</div>
    </div>

    <div id="ui-layer">Score: <span id="score">0</span></div>
    <div id="video-container"><video id="input-video"></video></div>

    <script>
        /** * CONSTANTS & CONFIG 
         */
        const DISK_COUNT = 4;
        const AIM_ASSIST_RADIUS = 0.15; // Normalized coordinates
        const DETECTION_INTERVAL = 30; // ms between AI checks
        let score = 0;
        let lastDetectionTime = 0;
        let isTriggerDown = false;

        /** * THREE.JS SETUP 
         */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 1, 2);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Laser & Crosshair
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]);
        const laserMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
        const laserLine = new THREE.Line(laserGeometry, laserMaterial);
        scene.add(laserLine);

        const crosshair = new THREE.Mesh(
            new THREE.RingGeometry(0.02, 0.03, 32),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide })
        );
        scene.add(crosshair);

        /** * GAME OBJECTS (DISCS) 
         */
        const discs = [];
        function createDisc() {
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
            const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
            const disc = new THREE.Mesh(geometry, material);
            
            resetDisc(disc);
            scene.add(disc);
            discs.push(disc);
        }

        function resetDisc(disc) {
            // Spawn at edges
            const side = Math.floor(Math.random() * 4);
            if(side === 0) { disc.position.set(-10, (Math.random()-0.5)*10, -15); }
            else if(side === 1) { disc.position.set(10, (Math.random()-0.5)*10, -15); }
            else if(side === 2) { disc.position.set((Math.random()-0.5)*15, 8, -15); }
            else { disc.position.set((Math.random()-0.5)*15, -8, -15); }
            
            disc.rotation.x = Math.PI / 2;
            // Velocity towards center
            disc.userData.velocity = new THREE.Vector3().copy(disc.position).multiplyScalar(-0.005);
            disc.userData.velocity.z = (Math.random() * 0.02); // slight drift forward
        }

        for(let i=0; i<DISK_COUNT; i++) createDisc();

        /** * AUDIO SYSTEM (Web Audio API) 
         */
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playHitSound(freq = 440, type = 'square') {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        /** * GESTURE & AI LOGIC 
         */
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        function onResults(results) {
            try {
                if (document.getElementById('loading-overlay')) {
                    document.getElementById('loading-overlay').remove();
                }

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Landmark indices: 8 (Index Tip), 5 (Index Base), 4 (Thumb Tip)
                    const indexTip = landmarks[8];
                    const indexBase = landmarks[5];
                    const thumbTip = landmarks[4];

                    // Map screen coordinates (MediaPipe is 0-1) to 3D Space
                    // We flip X because the video is mirrored
                    const targetX = (0.5 - indexTip.x) * 20; 
                    const targetY = (0.5 - indexTip.y) * 15;
                    
                    updateReticle(targetX, targetY);
                    checkTrigger(thumbTip, indexBase);
                }
            } catch (e) {
                console.error("Gesture Loop Error:", e);
            }
        }

        function updateReticle(tx, ty) {
            let finalX = tx;
            let finalY = ty;

            // Magnetic Aim Assist
            discs.forEach(d => {
                const dist = Math.sqrt(Math.pow(d.position.x - tx, 2) + Math.pow(d.position.y - ty, 2));
                if (dist < 2.5) { // Attraction radius in world units
                    finalX = THREE.MathUtils.lerp(tx, d.position.x, 0.6);
                    finalY = THREE.MathUtils.lerp(ty, d.position.y, 0.6);
                    crosshair.material.color.setHex(0xff0000);
                } else {
                    crosshair.material.color.setHex(0x00ff00);
                }
            });

            crosshair.position.set(finalX, finalY, -10);
            laserLine.rotation.y = finalX * 0.05;
            laserLine.rotation.x = -finalY * 0.05;
        }

        function checkTrigger(thumb, indexBase) {
            // Distance between thumb tip and index finger base
            const dist = Math.sqrt(
                Math.pow(thumb.x - indexBase.x, 2) + 
                Math.pow(thumb.y - indexBase.y, 2)
            );

            // If thumb is close to index base, it's a "press"
            if (dist < 0.08) {
                if (!isTriggerDown) {
                    shoot();
                    isTriggerDown = true;
                }
            } else {
                isTriggerDown = false;
            }
        }

        function shoot() {
            let hit = false;
            discs.forEach(d => {
                const dist = crosshair.position.distanceTo(d.position);
                if (dist < 1.0) {
                    spawnVFX("HIT", true);
                    playHitSound(600, 'sine');
                    resetDisc(d);
                    score += 10;
                    hit = true;
                }
            });

            if (!hit) {
                spawnVFX("MISS", false);
                playHitSound(150, 'sawtooth');
            }
            document.getElementById('score').innerText = score;
        }

        function spawnVFX(text, isHit) {
            const el = document.createElement('div');
            el.className = 'vfx-text';
            el.innerText = text;
            el.style.left = '50%';
            el.style.top = '50%';
            el.style.color = isHit ? '#00ff00' : '#ff0000';
            el.style.fontSize = isHit ? '40px' : '24px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        /** * CAMERA & RENDER LOOP 
         */
        const videoElement = document.getElementById('input-video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                const now = performance.now();
                if (now - lastDetectionTime > DETECTION_INTERVAL) {
                    await hands.send({image: videoElement});
                    lastDetectionTime = now;
                }
            },
            width: 1280,
            height: 720
        });
        cameraUtils.start();

        function animate() {
            requestAnimationFrame(animate);
            
            // Move Discs
            discs.forEach(d => {
                d.position.add(d.userData.velocity);
                d.rotation.y += 0.05;
                
                // Reset if they go too far behind or off screen
                if (d.position.z > 5) resetDisc(d);
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
